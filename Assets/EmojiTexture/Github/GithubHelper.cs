using System.Collections.Generic;using System.Collections;using System.IO;using UnityEngine;using System.Linq;using System;namespace iBicha.Github{    public class GithubHelper    {        const string API_ENDPOINT = "https://api.github.com/emojis";        const string CACHE_FILENAME = "emojiDict.json";        //Map from keyword to url        private static Dictionary<string, object> mapKeyword = new Dictionary<string, object>();        //Map from unicode to url        private static Dictionary<int, string> mapUnicode = new Dictionary<int, string>();        public static bool IsInitialized { get; private set; }        public static string Version { get; private set; }        public static IEnumerator Initialize(bool forceRefresh = false)        {            if (IsInitialized)                yield break;            string filename = Path.Combine(Application.persistentDataPath, CACHE_FILENAME);            string jsonString = null;            if (File.Exists(filename) && !forceRefresh)            {                jsonString = File.ReadAllText(filename);            }            else            {                using (var www = new WWW("https://api.github.com/emojis"))                {                    yield return www;//api call                    if (!(www.isDone && string.IsNullOrEmpty(www.error)))                    {                        yield break;                    }                    jsonString = www.text;                    File.WriteAllText(filename, jsonString);                }            }            mapKeyword = Json.Deserialize(jsonString) as Dictionary<string, object>;            var first = (string)mapKeyword.Values.First();            if (first.Contains("?"))                Version = first.Substring(first.IndexOf("?", StringComparison.Ordinal) + 1);            LoadUnicodeMap();            IsInitialized = true;        }        public static IEnumerator SetGithubEmoji(EmojiTexture emojiTexture, string text)        {            if (string.IsNullOrEmpty(text))                yield break;            if (!IsInitialized)                yield return Initialize();            int unicode;            if (text.StartsWith(":", StringComparison.Ordinal) && text.EndsWith(":", StringComparison.Ordinal)               && mapKeyword.ContainsKey(text.Trim(':')))            {                text = Path.GetFileNameWithoutExtension((string)mapKeyword[text.Trim(':')]);            }            if (text.Length == 1)            {                unicode = text[0];            }            else if (char.IsSurrogatePair(text, 0))            {                unicode = char.ConvertToUtf32(text, 0);            }            else if (!int.TryParse(text, System.Globalization.NumberStyles.HexNumber, null, out unicode))            {                yield break;            }            yield return SetGithubEmoji(emojiTexture, unicode);        }        public static IEnumerator SetGithubEmoji(EmojiTexture emojiTexture, int unicode)        {            if (!IsInitialized)                yield return Initialize();            if (!mapUnicode.ContainsKey(unicode))            {                yield break;            }            string text = char.ConvertFromUtf32(unicode);            string url = mapUnicode[unicode];            yield return emojiTexture.Download(url, text);        }        public static bool IsValid(int unicode)        {            if (!IsInitialized)                return false;            return mapUnicode.ContainsKey(unicode);        }        public static bool IsValid(string text)        {            if (!IsInitialized)                return false;            int unicode;            if (text.StartsWith(":", StringComparison.Ordinal) && text.EndsWith(":", StringComparison.Ordinal)                && mapKeyword.ContainsKey(text.Trim(':')))            {                text = Path.GetFileNameWithoutExtension((string)mapKeyword[text.Trim(':')]);            }            if (!int.TryParse(text, System.Globalization.NumberStyles.HexNumber, null, out unicode))            {                return false;            }            if (!mapUnicode.ContainsKey(unicode))            {                return false;            }            return true;        }        private static void LoadUnicodeMap()        {            foreach (var pair in mapKeyword)            {                var hex = Path.GetFileNameWithoutExtension((string)pair.Value);                int unicode;                if (int.TryParse(hex, System.Globalization.NumberStyles.HexNumber, null, out unicode))                {                    if (!mapUnicode.ContainsKey(unicode))                        mapUnicode.Add(unicode, (string)pair.Value);                }            }        }    }}